<h1 id="pyramids"><a target="_blank" href="http://github.com/scijs/pyramids">Pyramids</a></h1>
<p>Image pyramids give a (slightly) overcomplete multiscale representation of an image, based on a reduce operator that reduces the size of an image by a factor of two (note though that conventionally, level 0 is the original scale, and higher levels correspond to smaller sizes). Example usage:</p>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">pyramid</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;pyramids&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">ndarray</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;ndarray&quot;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">pyramid</span><span class="p">(</span><span class="nx">ndarray</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> <span class="nx">pyramid</span><span class="p">.</span><span class="nx">adjunction</span><span class="p">)</span>
</code></pre>
<p>The above computes a pyramid using erosion (local minima, in this case within each 2-by-2 block), of the following &quot;image&quot; (array):</p>
<table>
<tr><td align="right">11</td><td align="right">10</td><td align="right">6</td><td align="right">12</td><td align="right">3</td></tr>
<tr><td align="right">2</td><td align="right">15</td><td align="right">9</td><td align="right">4</td><td align="right">5</td></tr>
<tr><td align="right">14</td><td align="right">7</td><td align="right">13</td><td align="right">8</td><td align="right">1</td></tr>
</table>

<p>The result is a list of ndarrays, with the first array (corresponding to level 0) being the original ndarray object. The array at level 1 is given by:</p>
<table>
<tr><td align="right">2</td><td align="right">4</td><td align="right">3</td></tr>
<tr><td align="right">7</td><td align="right">8</td><td align="right">1</td></tr>
</table>

<h3 id="-require-pyramids-array-scheme-maxlevel-"><code>require(&quot;pyramids&quot;)(array, scheme[, maxlevel])</code></h3>
<p>Returns a list containing <code>array</code>, followed by <code>maxlevel</code> (higher) levels of a pyramid based on the reduce operator of <code>scheme</code> (each an ndarray with the same type of data storage as <code>array</code>). If <code>maxlevel</code> is unspecified, it returns as many levels are necessary to end up with an array containing just one element. Note that the first level is simply the argument given to the function.</p>
<p>There is no restriction on the dimensionality of <code>array</code>, but a typed array must be used for storing the data in <code>array</code> (otherwise the pool allocator used internally will fail).</p>
<h3 id="-require-pyramids-detail-array-scheme-maxlevel-"><code>require(&quot;pyramids&quot;).detail(array, scheme[, maxlevel])</code></h3>
<p>Same as <code>require(&quot;pyramids&quot;)</code>, but generates a detail pyramid. That is, all but the last level have been generated by expanding the next level and subtracting it from the current level.</p>
<h3 id="-require-pyramids-reconstruct-detailpyramid-scheme-"><code>require(&quot;pyramids&quot;).reconstruct(detailPyramid, scheme)</code></h3>
<p>Reconstructs an image from a given detail pyramid (as output by the <code>detail</code> function). The reconstruction is done in-place. For example:</p>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">pyramid</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;pyramids&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">pyramid</span><span class="p">.</span><span class="nx">detail</span><span class="p">(</span><span class="nx">ndarray</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> <span class="nx">pyramid</span><span class="p">.</span><span class="nx">adjunction</span><span class="p">)</span>
<span class="c1">// do something with the detail pyramid</span>
<span class="nx">pyramid</span><span class="p">.</span><span class="nx">reconstruct</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">pyramid</span><span class="p">.</span><span class="nx">adjunction</span><span class="p">)</span>
<span class="c1">// p now contains a normal pyramid (with the first level corresponding to the full resolution reconstructed image)</span>
</code></pre>
<h2 id="morphological-pyramids">Morphological pyramids</h2>
<p>Non-linear pyramids based on reduce and expand operators that satisfy the so-called pyramid condition: first expanding an image and then reducing it recovers the original image.</p>
<h3 id="-require-pyramids-adjunction-"><code>require(&quot;pyramids&quot;).adjunction</code></h3>
<p>The adjunction pyramid has a reduce operator based on erosion, as described in</p>
<blockquote>
<p>Nonlinear multiresolution signal decomposition schemes &#x2014; Part I: Morphological pyramids &apos;&apos;IEEE Transactions on Image Processing&apos;&apos;, Vol. 9, No. 11. (November 2000), pp. 1862-1876, doi:<a href="http://dx.doi.org/10.1109/83.877209">10.1109/83.877209</a> by John Goutsias, Henk J. A. M. Heijmans.</p>
</blockquote>
<p>The structuring element used here is a (flat) 2-by-2 square in 2D, and in general a hypercube with sides of length 2. The expand operator uses the dilation that forms an adjunction with the erosion.</p>
<h3 id="-require-pyramids-sunmaragos-"><code>require(&quot;pyramids&quot;).SunMaragos</code></h3>
<p>The SunMaragos pyramid has an opening (rather than an erosion) as reduce operator. The same structuring element is used as in the adjunction pyramid, based on the results in</p>
<blockquote>
<p>A New Class of Morphological Pyramids for Multiresolution Image Analysis In Geometry, Morphology, and Computational Imaging, Vol. 2616 (2003), pp. 165-175, doi:<a href="http://dx.doi.org/10.1007/3-540-36586-9_11">10.1007/3-540-36586-9_11</a> by Jos B. T. M. Roerdink edited by Tetsuo Asano, Reinhard Klette, Christian Ronse.</p>
</blockquote>
<p>This pyramid tends to preserve more of the image than the adjunction pyramid. However, the same expand operator is used as for the adjunction pyramid. Note that (according to Goutsias and Heijmans, 2000) Sun and Maragos originally used a different structuring element (of length 3).</p>
<h2 id="linear-pyramids">Linear pyramids</h2>
<p>Non-linear pyramids based on reduce and expand operators that satisfy the so-called pyramid condition: first expanding an image and then reducing it recovers the original image.</p>
<h3 id="-require-pyramids-binomial-"><code>require(&quot;pyramids&quot;).binomial</code></h3>
<p>This is a very basic pyramid that is not ideal for all purposes. However, it is essentially equivalent to the traditional Gaussian pyramid, and the Laplacian pyramid if a detail pyramid is computed. It uses a binomial filter (<code>[1,4,6,4,1]/16</code>) with the reduce and expand operators defined here:</p>
<blockquote>
<p>The Laplacian Pyramid as a Compact Image Code &apos;&apos;IEEE Transactions on Communications&apos;&apos;, Vol. 31, No. 4. (April 1983), pp. 532-540, doi:<a href="http://dx.doi.org/10.1109/tcom.1983.1095851">10.1109/tcom.1983.1095851</a> by Peter J. Burt, Edward H. Adelson</p>
</blockquote>
